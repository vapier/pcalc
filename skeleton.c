                                    /* A lexical scanner generated by flex */

#include "skeleton.h"

%% section 1 code and data tables for DFA go here

/* these declarations have to come after the section 1 code or lint gets
 * confused about whether the variables are used
 */
FILE *yyin = stdin, *yyout = stdout;

/* these variables are all declared out here so that section 3 code can
 * manipulate them
 */
static int yy_start, yy_b_buf_p, yy_c_buf_p, yy_e_buf_p;
static int yy_saw_eof, yy_init = 1;

/* yy_ch_buf has to be 1 character longer than YY_BUF_SIZE, since when
 * setting up yytext we can try to put a '\0' just past the end of the
 * matched text
 */
static char yy_ch_buf[YY_BUF_SIZE + 1];
static int yy_st_buf[YY_BUF_SIZE];
static char yy_hold_char;

static char input( void) ;
static void unput( char) ;

char *yytext;
static int yyleng;

/*-------------------------------------------------------------------------*/
/*------------------------- BEGIN LEXICAL ANALYZER ------------------------*/
/*-------------------------------------------------------------------------*/

YY_DECL
    {
    int yy_n_chars, yy_lp, yy_iii, yy_buf_pos, yy_act;
#ifdef FLEX_REJECT_ENABLED
    int yy_full_match;
#endif

%% user's declarations go here

    if ( yy_init )
    {
    YY_INIT;
    yy_start = 1;
    yy_init = 0;
    }

    goto get_next_token;

do_action:

#ifdef FLEX_REJECT_ENABLED
       /* remember matched text in case we back up due to trailing context */
    yy_full_match = yy_c_buf_p;
#endif

    for ( ; ; )
    {
    YY_DO_BEFORE_ACTION

#ifdef FLEX_DEBUG
    fprintf( stderr, "--accepting rule #%d\n", yy_act );
#endif
    switch ( yy_act )
        {
%% actions go here

case YY_NEW_FILE:
break;                                      /* begin reading from new file */

case YY_END_TOK:
return ( YY_END_TOK );

default:
YY_FATAL_ERROR( "fatal flex scanner internal error" );
        }

get_next_token:
    {
    register int yy_curst;
    register char yy_sym;

    YY_DO_BEFORE_SCAN

                                            /* set up to begin running DFA */

    yy_curst = yy_start;

    if ( yy_ch_buf[yy_c_buf_p] == '\n' )
        ++yy_curst;

    /* yy_b_buf_p points to the position in yy_ch_buf
     * of the start of the current run.
     */

    yy_b_buf_p = yy_c_buf_p + 1;

    do                                           /* until the machine jams */
        {
        if ( yy_c_buf_p == yy_e_buf_p )
       {                                                /* need more input */
       if ( yy_e_buf_p >= YY_BUF_LIM )
           {                         /* not enough room to do another read */
                            /* see if we can make some room for more chars */

           yy_n_chars = yy_e_buf_p - yy_b_buf_p;

           if ( yy_n_chars >= 0 )
                                         /* shift down buffer to make room */
         for ( yy_iii = 0; yy_iii <= yy_n_chars; ++yy_iii )
             {
             yy_buf_pos = yy_b_buf_p + yy_iii;
             yy_ch_buf[yy_iii] = yy_ch_buf[yy_buf_pos];
             yy_st_buf[yy_iii] = yy_st_buf[yy_buf_pos];
             }

           yy_b_buf_p = 0;
           yy_e_buf_p = yy_n_chars;

           if ( yy_e_buf_p >= YY_BUF_LIM )
         YY_FATAL_ERROR( "flex input buffer overflowed" );

           yy_c_buf_p = yy_e_buf_p;
           }

       else if ( yy_saw_eof )
           {
saweof:         if ( yy_b_buf_p > yy_e_buf_p )
         {
         if ( yywrap() )
             {
             yy_act = YY_END_TOK;
             goto do_action;
             }
         
         else
             {
             YY_INIT;
             yy_act = YY_NEW_FILE;
             goto do_action;
             }
         }

           else                           /* do a jam to eat up more input */
         {
#ifndef FLEX_INTERACTIVE_SCANNER
         /* we're going to decrement yy_c_buf_p upon doing
          * the jam.  In this case, that's wrong, since
          * it points to the last non-jam character.  So
          * we increment it now to counter the decrement.
          */
         ++yy_c_buf_p;
#endif
         break;
         }
           }

       YY_INPUT( (yy_ch_buf + yy_c_buf_p + 1), yy_n_chars,
           YY_MAX_LINE );

       if ( yy_n_chars == YY_NULL )
           {
           if ( yy_saw_eof )
    YY_FATAL_ERROR( "flex scanner saw EOF twice - shouldn't happen" );
           yy_saw_eof = 1;
           goto saweof;
           }

       yy_e_buf_p += yy_n_chars;
       }

        ++yy_c_buf_p;

#ifdef FLEX_USE_ECS
        yy_sym = e[yy_ch_buf[yy_c_buf_p]];
#else
        yy_sym = yy_ch_buf[yy_c_buf_p];
#endif

#ifdef FLEX_FULL_TABLE
        yy_curst = n[yy_curst][yy_sym];

#else                              /* get next state from compressed table */

        while ( c[b[yy_curst] + yy_sym] != yy_curst )
       {
       yy_curst = d[yy_curst];

#ifdef FLEX_USE_MECS
       /* we've arrange it so that templates are never chained
        * to one another.  This means we can afford make a
        * very simple test to see if we need to convert to
        * yy_sym's meta-equivalence class without worrying
        * about erroneously looking up the meta-equivalence
        * class twice
        */

       if ( yy_curst >= YY_TEMPLATE )
           yy_sym = m[yy_sym];
#endif
       }

        yy_curst = n[b[yy_curst] + yy_sym];

#endif

        yy_st_buf[yy_c_buf_p] = yy_curst;

        }
#ifdef FLEX_INTERACTIVE_SCANNER
    while ( b[yy_curst] != YY_JAM_BASE );
#else
    while ( yy_curst != YY_JAM );
    --yy_c_buf_p;                       /* put back character we jammed on */

#endif

    if ( yy_c_buf_p >= yy_b_buf_p )
        {                                          /* we matched some text */
        yy_curst = yy_st_buf[yy_c_buf_p];
        yy_lp = l[yy_curst];

#ifdef FLEX_REJECT_ENABLED
find_rule:                  /* we branch to this label when doing a REJECT */
#endif

        for ( ; ; )                  /* until we find what rule we matched */
       {
#ifdef FLEX_REJECT_ENABLED
       if ( yy_lp && yy_lp < l[yy_curst + 1] )
           {
           yy_act = a[yy_lp];
           goto do_action;                                 /* "continue 2" */
           }
#else
       if ( yy_lp )
           {
           yy_act = yy_lp;
           goto do_action;                                 /* "continue 2" */
           }
#endif

       if ( --yy_c_buf_p < yy_b_buf_p )
           break;

       yy_curst = yy_st_buf[yy_c_buf_p];
       yy_lp = l[yy_curst];
       }
        }

    YY_FATAL_ERROR( "no match in flex scanner - possible NULL in input" );
    }
    }

                                                               /*NOTREACHED*/
    }

static  void unput( c )
char c;
{
 register int i;
 register int yy_buf_pos ;

    YY_DO_BEFORE_SCAN;                /* undo effects of setting up yytext */

    if ( yy_c_buf_p == 0 )
    {
    yy_buf_pos = YY_BUF_MAX ;
    for ( i = yy_e_buf_p; i >= yy_c_buf_p; --i )
        {
        yy_ch_buf[yy_buf_pos] = yy_ch_buf[i];
        yy_st_buf[yy_buf_pos] = yy_st_buf[i];
        --yy_buf_pos;
        }

    yy_c_buf_p = YY_BUF_MAX - yy_e_buf_p;
    yy_e_buf_p = YY_BUF_MAX;
    }

    if ( yy_c_buf_p <= 0 )
    YY_FATAL_ERROR( "flex scanner push-back overflow" );

    if ( yy_c_buf_p >= yy_b_buf_p && yy_ch_buf[yy_c_buf_p] == '\n' )
    yy_ch_buf[yy_c_buf_p - 1] = '\n';

    yy_ch_buf[yy_c_buf_p--] =  c;

    YY_DO_BEFORE_ACTION;                            /* set up yytext again */

    }

static char input( void)
{
    char c;

    YY_DO_BEFORE_SCAN

    if ( yy_c_buf_p == yy_e_buf_p )
    {                                                   /* need more input */
    int yy_n_chars;

                            /* we can throw away the entire current buffer */
    if ( yy_saw_eof )
        {
        if ( yywrap() )
       return ( EOF );

        YY_INIT;
        }

    yy_b_buf_p = 0;
    YY_INPUT( yy_ch_buf, yy_n_chars, YY_MAX_LINE );

    if ( yy_n_chars == YY_NULL )
    {
        yy_saw_eof = 1;

        if ( yywrap() )
       return ( EOF );

        YY_INIT;

        return ( input() );
    }

    yy_c_buf_p = -1;
    yy_e_buf_p = yy_n_chars - 1;
    }

    c = (unsigned char) yy_ch_buf[++yy_c_buf_p];

    YY_DO_BEFORE_ACTION;

    return ( c );
    }

/*-------------------------------------------------------------------------*/
/*------------------------- END OF LEXICAL ANALYZER -----------------------*/
/*-------------------------------------------------------------------------*/

